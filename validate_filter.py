#!/usr/bin/env python3
"""
Compare software-filtered image with HDL output.

* Reads input   – from input.hex (if present) else input.png (auto-resize 128×128)
* Runs a 3×3 convolution in Python (default: sharpen)
* Reads HDL result from output.hex (same 128×128 format)
* Calculates SSIM, absolute-difference heat-map, and
  produces an overlay: grey SW image + red pixels where SW ≠ HDL
"""

import os, re, numpy as np
from PIL import Image
from skimage.metrics import structural_similarity as ssim
import matplotlib.pyplot as plt

# ------------------------------------------------------------------
# global parameters (change only if your RTL image size changes)
IMG_H, IMG_W = 128, 128
IN_PNG  = "input.png"         # generated by Makefile (for reference only)
IN_HEX  = "input.hex"         # generated by Makefile – always 128×128
HDL_HEX = "output.hex"        # produced by vvp

# ------------------------------------------------------------------
# 3×3 kernel – must match the filter you load in Verilog
kernel = np.array([[ 0, -1,  0],
                   [-1,  5, -1],
                   [ 0, -1,  0]], dtype=np.int8)      # ← sharpen
# e.g. Gaussian blur ×256:
# kernel = np.array([[16,32,16],[32,64,32],[16,32,16]], dtype=np.int16)

# ------------------------------------------------------------------
def read_hex_image(fname, h=IMG_H, w=IMG_W):
    """
    Read raw Verilog .hex (1 byte/line) -> uint8 image [h, w].
    Ignores '//' comments and replaces any 'x' with 0.
    """
    flat, unknown = [], 0
    with open(fname) as f:
        for raw in f:
            # strip comments
            line = raw.split('//', 1)[0].strip()
            if not line:
                continue
            # replace unknowns
            if re.search(r'[xX]', line):
                line = re.sub(r'[xX]', '0', line)
                unknown += 1
            flat.append(int(line, 16) & 0xFF)

    if len(flat) != h * w:
        raise ValueError(f"{fname}: expected {h*w} bytes, got {len(flat)}")
    if unknown:
        print(f"[warn] {unknown} 'x' bytes forced to 0")

    return np.array(flat, dtype=np.uint8).reshape((h, w))

# ------------------------------------------------------------------
def convolve3x3(img, k):
    """Naïve 3×3 convolution, 0-padding at the border."""
    out = np.zeros_like(img, dtype=np.uint8)
    for i in range(1, img.shape[0] - 1):
        for j in range(1, img.shape[1] - 1):
            window = img[i-1:i+2, j-1:j+2]
            acc = int((window * k).sum())
            out[i, j] = np.clip(acc, 0, 255)
    return out

# ===== 1. Load the image given to RTL ========================================
if os.path.exists(IN_HEX):
    print(">> Using input.hex (exactly 128×128)")
    src = read_hex_image(IN_HEX)
else:
    print(">> Using input.png (resized to 128×128)")
    src = np.array(Image.open(IN_PNG).convert("L")
                   .resize((IMG_W, IMG_H), Image.LANCZOS), dtype=np.uint8)

# ===== 2. Software reference =================================================
sw  = convolve3x3(src, kernel)

# ===== 3. HDL result =========================================================
hdl = read_hex_image(HDL_HEX)

# ===== 4. Quality metrics + abs diff ========================================
core_sw  = sw[1:-1, 1:-1]                   # ignore 1-pixel border
core_hdl = hdl[1:-1, 1:-1]
diff     = np.abs(core_sw.astype(int) - core_hdl.astype(int))

print(f"SSIM(SW vs HDL) = {ssim(core_sw, core_hdl):.4f}")

# ===== 5. Build overlay: grey SW + red difference pixels =====================
overlay = np.stack([sw]*3, axis=-1)         # -> RGB copy of SW
mask = np.pad(diff > 0, ((1,1), (1,1)))     # back to 128×128
overlay[mask, 0] = 255                      # full red
overlay[mask, 1:] //= 2                     # dim G/B -> red pop-out

# ===== 6. Display ============================================================
plt.figure(figsize=(13, 4))

plt.subplot(1, 4, 1)
plt.title("Software"); plt.imshow(sw,  cmap="gray"); plt.axis("off")

plt.subplot(1, 4, 2)
plt.title("HDL");      plt.imshow(hdl, cmap="gray"); plt.axis("off")

plt.subplot(1, 4, 3)
plt.title("|SW – HDL|")
hm = plt.imshow(diff, cmap="inferno", vmin=0, vmax=5)  # highlight up to 5 LSB
plt.axis("off"); plt.colorbar(hm, fraction=0.045)

plt.subplot(1, 4, 4)
plt.title("Overlay"); plt.imshow(overlay); plt.axis("off")

plt.tight_layout(); plt.show()
